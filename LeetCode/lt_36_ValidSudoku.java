
public class lt_36_ValidSudoku {

    // 回傳該 9x9 棋盤是否為有效數獨（僅檢查目前填入是否違規，不要求可被解出）
    public static boolean isValidSudoku(char[][] board) {
        // 3 個 9 長度陣列，分別代表 9 列、9 行、9 個 3x3 子宮格的使用情形
        // 用 bitmask 的第 k 位（0..8）表示數字 (k+1) 是否已出現
        int[] rowMask = new int[9];
        int[] colMask = new int[9];
        int[] boxMask = new int[9];

        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                char ch = board[r][c];
                if (ch == '.') continue;  // 空格跳過

                int num = ch - '1';       // 將 '1'..'9' 映到 0..8
                int bit = 1 << num;       // 對應的位元

                int boxId = (r / 3) * 3 + (c / 3); // 3x3 子宮格索引：0..8

                // 若在同一列/行/子宮格已經出現相同數字，則違規
                if ((rowMask[r] & bit) != 0) return false;
                if ((colMask[c] & bit) != 0) return false;
                if ((boxMask[boxId] & bit) != 0) return false;

                // 標記這個數字已被使用
                rowMask[r] |= bit;
                colMask[c] |= bit;
                boxMask[boxId] |= bit;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        char[][] valid = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(isValidSudoku(valid)); // true

        char[][] invalidRow = {
            {'5','3','5','.','7','.','.','.','.'}, // 同列有兩個 '5'
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(isValidSudoku(invalidRow)); // false
    }
}

/*
【解題思路】

題目：判斷 9x9 棋盤是否「目前有效」。
有效的定義是：任一列、任一行、任一 3x3 子宮格都不可出現重複的 1..9。
注意：題目只要求檢查目前盤面是否違規，並不要求能不能解得出解（不需回溯）。

核心觀念（一次掃描、三種約束）：
- 對每個非 '.' 的格子 (r,c)，數字 d 必須同時滿足：
  1) 該列 r 尚未出現 d
  2) 該行 c 尚未出現 d
  3) 該 3x3 子宮格 boxId 尚未出現 d，其中 boxId = (r/3)*3 + (c/3)

資料結構（位元遮罩 bitmask）：
- rowMask[9], colMask[9], boxMask[9]
- 將數字 d（1..9）映射到位元 (d-1)
- 若某列/行/子宮格已出現 d，對應 mask 的 (d-1) 位會是 1
- 檢查是否重複： (mask & (1 << (d-1))) != 0

流程：
for r=0..8:
  for c=0..8:
    - 若是 '.' 跳過
    - num = board[r][c] - '1'; bit = 1 << num
    - boxId = (r/3)*3 + (c/3)
    - 若 rowMask[r], colMask[c], boxMask[boxId] 任何一個已有 bit，代表重複 → 回傳 false
    - 否則把 bit 設進三個 mask

- 每個數字在每個約束（列/行/子宮格）只會在第一次出現時設位，若再次遇到同約束的同數字，會被偵測為重複。
- 由於僅有 81 格且每格常數次操作，時間為 O(81)；三個長度 9 的陣列空間為 O(1) 級別。

時間複雜度：O(81) ≈ O(1)
空間複雜度：O(1)
*/
